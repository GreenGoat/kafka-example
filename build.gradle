import groovy.time.TimeCategory
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

plugins {
	id 'java'
	id 'org.springframework.boot' version '3.1.4'
	id 'io.spring.dependency-management' version '1.1.3'
	id 'jacoco'
}

group = 'au.com.example.kafka'
version = '0.0.1-SNAPSHOT'

java {
	sourceCompatibility = '17'
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
}

ext {
	set('springCloudVersion', "2022.0.1")
	set('jackson-bom.version', '2.15.0') // TODO remove this when spring bumps this one
}

dependencyManagement {
	dependencies {
		dependency 'org.apache.bcel:bcel:6.7.0'
	}

	imports {
		mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"
	}
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.kafka:spring-kafka'
	implementation 'org.postgresql:postgresql'
	implementation 'org.liquibase:liquibase-core'
	implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'
	implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jdk8'
	implementation 'org.springframework.data:spring-data-envers'
	testImplementation 'org.projectlombok:lombok:1.18.28'
	compileOnly 'org.projectlombok:lombok'
	annotationProcessor 'org.projectlombok:lombok'

	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'org.springframework.kafka:spring-kafka-test'

	testImplementation platform('org.testcontainers:testcontainers-bom:1.18.3')
	testImplementation 'org.testcontainers:postgresql'
	testImplementation "org.testcontainers:junit-jupiter"
	testImplementation 'org.awaitility:awaitility'
}

tasks.register("deps", DependencyReportTask) {
	// https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/diagnostics/DependencyReportTask.html
	setOutputFile(new File("./dependencies.txt"))
}


ext.testsResults = [] // Container for tests summaries

test { testTask ->
	useJUnitPlatform()
	systemProperty 'spring.profiles.active', 'test'
	finalizedBy jacocoTestReport
	testLogging {
		// set options for log level LIFECYCLE
		events TestLogEvent.FAILED,
				TestLogEvent.PASSED,
				TestLogEvent.SKIPPED,
				TestLogEvent.STANDARD_ERROR,
				TestLogEvent.STANDARD_OUT
		exceptionFormat TestExceptionFormat.FULL
		showExceptions true
		showCauses true
		showStackTraces true


		// set options for log level DEBUG and INFO
		debug {
			events TestLogEvent.STARTED,
					TestLogEvent.FAILED,
					TestLogEvent.PASSED,
					TestLogEvent.SKIPPED,
					TestLogEvent.STANDARD_ERROR,
					TestLogEvent.STANDARD_OUT
			exceptionFormat TestExceptionFormat.FULL
		}
		info.events = debug.events
		info.exceptionFormat = debug.exceptionFormat

		afterSuite { desc, result ->

			if (desc.parent) return // Only summarize results for whole modules

			String summary = "${testTask.project.name}:${testTask.name} results: ${result.resultType} " +
					"(" +
					"${result.testCount} tests, " +
					"${result.successfulTestCount} successes, " +
					"${result.failedTestCount} failures, " +
					"${result.skippedTestCount} skipped" +
					") " +
					"in ${TimeCategory.minus(new Date(result.endTime), new Date(result.startTime))}" +
					"\n" +
					"Report file: ${testTask.reports.html.entryPoint}"

			// Add reports in `testsResults`, keep failed suites at the end
			if (result.resultType == TestResult.ResultType.SUCCESS) {
				rootProject.testsResults.add(0, summary)
			} else {
				rootProject.testsResults += summary
			}
		}
	}
}

jacocoTestReport {
	dependsOn test
	reports {
		xml.required = false
		csv.required = false
		html.outputLocation = layout.buildDirectory.dir("reports/jacoco")
	}
}

gradle.buildFinished {
	def allResults = rootProject.ext.testsResults

	if (!allResults.isEmpty()) {
		printResults allResults
	}
}

private static void printResults(allResults) {
	def maxLength = allResults*.readLines().flatten().collect { it.length() }.max()

	println "┌${"${"─" * maxLength}"}┐"

	println allResults.collect {
		it.readLines().collect {
			"│" + it + " " * (maxLength - it.length()) + "│"
		}.join("\n")
	}.join("\n├${"${"─" * maxLength}"}┤\n")

	println "└${"${"─" * maxLength}"}┘"
}

allprojects {
	// add a collection to track failedTests
	ext.failedTests = []

	// add a testlistener to all tasks of type Test
	tasks.withType(Test) {
		afterTest { TestDescriptor descriptor, TestResult result ->
			if(result.resultType == org.gradle.api.tasks.testing.TestResult.ResultType.FAILURE){
				failedTests << ["${descriptor.className}::${descriptor.name}"]
			}
		}
	}

	// print out tracked failed tests when the build has finished
	gradle.buildFinished {
		if(!failedTests.empty){
			println "Failed tests for ${project.name}:"
			failedTests.each { failedTest ->
				println failedTest
			}
			println ""
		}
	}
}
